<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Functional programming: like Erlang but in Javascript!</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>Functional programming</h1>
					<h3>like Erlang but in Javascript!</h3>
					<p>
						<small>Created by <a href="http://hakim.se">Guido D'Orsi</a> / <a href="http://twitter.com/fughye">@fughye</a></small>
					</p>
				</section>

				<section>
					<h2>Di cosa parleremo?</h2>
					<ul>
						<li>
							Tecniche di programmazione funzionale
							applicabili nel nostro quotidiano
						</li>
						<li>Esempi di vita reale</li>
						<li>Unicorni volanti</li>
					</ul>
				</section>

				<section>
					<h2>Perchè passare ad un approccio più funzionale?</h2>
					<ul>
						<li>Facile suddivisione delle responsabilità</li>
						<li>Semplicità</li>
						<li>Testabilità</li>
						<li>Prossimamente parleremo di Redux</li>
					</ul>

					<aside class="notes">
						Sviluppare software senza attenersi a dei principi di design porta sempre a risultati scadenti sotto tutti i punti di vista.
						Costi di produzione, tempi di sviluppo, User Experience, poca affidabilità del codice, poca manuntenibiltà.
						Con questo breve talk non intendo mostrarvi che sono stato illuminato dal signore e l'unica strada giusta è programmare abbandonando completamente l'approccio
						Object-Oriented o procedurale e passando a un funzionale puro.
						La mia intenzione è di portarvi quella che è la mia esperienza nell'applicare principi di programmazione funzionale nel lavoro di tutti i giorni e i benefici
						che questo comporta.
						Inoltre è mia intenzione quella di portare prossimamente qui un talk su Redux, una libreria davvero molto semplice e interessante, che serve a gestire lo stato delle interfaccie
						e che si basa molto sui concetti della programmazione funzionale.
					</aside>
				</section>

				<section data-markdown="shitty-geocoder.md">
					<aside class="notes">
						Iniziamo subito da un esempio di vita reale.
						Qui ho dato sfogo a tutta la mia fantasia per scrivere una classe di merda,
						che faccia geolocalizzazione di un indirizzo e mostri i risultati, tutti belli, al nostro caro utente.
					</aside>
				</section>

				<section>
					<h2>Esempio: Google Maps Geocoding</h2>
					<div>
						<input id="shitty-query-input" disabled="disabled" autofocus>
						<input id="shitty-geocode-button" type="button" value="Geocode"  disabled="disabled"/>
						<div id="shitty-geocode-result"></div>
					</div>

					<aside class="notes">
						Poi però arriva il nostro capo o cliente o chicchessia e ci chiede di mostrare
						tutti i risultati del geocoding.
						E noi smadonniamo perchè dobbiamo cambiare quasi tutto, con tutti i possibli errori che ne possono conseguire.
					</aside>
				</section>

				<section>
					<h2>First class functions</h2>
					<h3>Anche le funzioni possono viaggiare in prima classe!</h3>

					<aside class="notes">
						Passiamo adesso ad un pò di teoria.
						Come in algebra, se le funzioni rispettano determinate condizioni, hanno tante belle propietà che ci permettono di fare le nostre fighettate.
						Iniziamo con le funzioni di prima classe.
					</aside>
				</section>

				<section>
					<h2>Esempio</h2>
					<pre>
						<code class="hljs" data-trim contenteditable>
function GiveMeSomething(something) {
  this.something = something.replace('stuff', ''));
}

//Non è fist class.
GiveMeSomething.prototype.show = function() {
  console.log(this.something);
}

//First class
function showSomething(something) {
  console.log(something.replace('stuff', ''));
}
						</code>
					</pre>

					<aside class="notes">
						Le funzioni di prima classe sono funzioni che possono essere trattate come qualsiasi altro tipo di dato, e che non dipendono qundi dal contesto in cui si trovano (this).
					</aside>
				</section>

				<section>
					<h2>Perchè first class è meglio?</h2>
					<pre>
						<code class="hljs" data-trim contenteditable>
//Che brutta cosa
var _this = this;

this.geocoder.geocode({
  address: this.input.value
}, function (results, status) {
  _this.handleGeocodeResult(results, status);
});

//Già meglio
this.geocoder.geocode({
  address: this.input.value
}, this.handleGeocodeResult.bind(this));
						</code>
					</pre>

					<aside class="notes">
						Già così iniziamo a risparmiare inutili righe di codice.
						Immaginate a quanto sarebbe bello avere tutti i metodi del nostro Geocoder first class.

						Ecco che già ci stiamo pentendo di aver utilizzato una classe per gestire il nostro geocoding.
					</aside>
				</section>

				<section>
					<h2>Unicorni volanti</h2>
					<img src="large_unicorn.png">
				</section>

				<section>
					<h2>Pure functions</h2>
					<h3>La felicità di sentirsi puri!</h3>

					<aside class="notes">
						Si dice funzone pura, una funzione che dato un determinato input, ritorna sempre lo stesso output e non ha nessun osservabile side-effect.
						In pratica una funzione che ad ogni chiamata è sempre vergine.
					</aside>
				</section>

				<section>
					<pre>
						<code class="hljs" data-trim >
var list = [1, 2, 3, 4, 5];

// pure
list.slice(0, 3);
//=> [1, 2, 3]

list.slice(0, 3);
//=> [1, 2, 3]

// impure
list.splice(0, 3);
//=> [1, 2, 3]

list.splice(0, 3);
//=> [4, 5]
						</code>
					</pre>

					<aside class="notes">
						Prendiamo Slice e Splice. Sono due funzioni che fanno la stessa cosa, ma in modo differente.
						Slice ogni volta che riceve lo stesso input, ritorna sempre il medesimo output, garantito.
						Splice invece ad ogni chiamata ci taglia il nostro array mutandolo.

						Questo è un brutto side-effect e questa cosa a noi amanti della programmaizone funzionale non piace.
					</aside>
				</section>

				<section>
					<pre>
						<code class="hljs" data-trim >
// impure
var minimum = 2000000;

function sonoRicco(euro) {
  return euro >= minimum;
};

// pure
function sonoRicco(euro) {
  var minimum = 2000000;

  return euro >= minimum;
};
						</code>
					</pre>

					<aside class="notes">
						In questo caso invece la prima funzione è impura, in quanto dipende da una variabile esterna,
						che può cambiare nel corso del tempo influendo quindi sul risultato della funzione
					</aside>
				</section>

				<section>
					<h2>Esempi di side effects:</h2>
					<ul>
						<li>Mutazioni</li>
						<li>Effettuare una chiamata http</li>
						<li>Stampare a video oppure scrivere dei log</li>
						<li>Lanciare una query sul DOM</li>
						<li>Altro ancora...</li>
					</ul>

					<aside class="notes">
						Si dice funzone pura, una funzione che dato un determinato input, ritorna sempre lo stesso output.

						E quand'è che una funzione non rispetta questa condizione?
						Quando il risultato dipende da uno stato esterno.
					</aside>
				</section>

				<section>
					<section>
						<pre>
							<code class="hljs" data-trim>
//Quanta oscenità in un unica funzione!
Geocoder.prototype.showAddress = function () {
  var formattedData = this.locationData.province + ', ' +
  this.locationData.city + ', ' + this.locationData.route;

  if(this.locationData.streetNumber){
    formattedData += ' ' + this.locationData.streetNumber;
  }

  this.output.textContent = formattedData;
}
							</code>
						</pre>
					</section>

					<section>
						<pre>
							<code class="hljs" data-trim>
//Quanto è bello essere puri!
function formatAddress(locationData) {
  var formattedData = locationData.province + ', ' +
  locationData.city + ', ' + locationData.route;

  if(this.locationData.streetNumber){
    formattedData += ', ' + locationData.streetNumber;
  }

  return formattedData;
}

//Qui manteniamo ancora la purezza
function showAddress(output, formattedData) {
  //Anche se qualcuno il lavoro sporco lo deve ancora fare
  return function() {
    output.textContent = formattedData;
  };
}
							</code>
						</pre>
					</section>

					<aside class="notes">
						Che ci abbiamo guadagnato?

						showAddress prima aveva due responsabilità, era scocciante da testare con riusabilità zero.
						La nuova versione si testa facilmente, non è legata al nostro vecchio oggetto
						e possiamo farci quello che ci pare (caching).
					</aside>
				</section>

				<section>
					<h2>Currying</h2>

					<aside class="notes">
						Il concetto di currying è semplice. Puoi passare una funzione meno parametri di quanti ne aspetta.
						Questa ritornerà una nuova funzione che prenderà in input i restanti parametri.
					</aside>
				</section>

				<section>
					<pre>
						<code class="hljs" data-trim>
var curry = require('lodash/curry');

var match = curry(function (what, str){
  return str.match(what);
});

var hasSpaces = replace(/\s/g);

hasSpaces('Ciao a tuttii');
//true
						</code>
					</pre>

					<aside class="notes">
					</aside>
				</section>

				<section>
					<pre>
						<code class="hljs" data-trim>
var match = function (what, str){
  return str.match(what);
};

var hasSpaces = replace.bind(undefined, /\s/g);

hasSpaces('Ciao a tuttii');
//true
						</code>
					</pre>

					<aside class="notes">
					</aside>
				</section>

				<section>
					<section>
						<pre>
							<code class="hljs" data-trim>
function formatAddress(locationData) {
  var formattedData = locationData.province + ', ' +
    locationData.city + ', ' + locationData.route;

  if(this.locationData.streetNumber){
    formattedData += ', ' + locationData.streetNumber;
  }

  return formattedData;
}
							</code>
						</pre>

					</section>
					<section>
						<pre>
							<code class="hljs" data-trim>
var join =  curry(function (glue, array) {
  return array.join(glue);
});

var filter = curry(function (predicate, array) {
  return array.filter(predicate);
});

function isTruthy(value) {
  return !!value;
}

var joinWithComma = join(', ');
var filterInvalid = filter(isTruthy);
							</code>
						</pre>
					</section>
					<section>
						<pre>
							<code class="hljs" data-trim>
function locationDataToArray(locationData){
  return [
    locationData.province,
    locationData.city,
    locationData.route,
    locationData.streetNumber
  ];
}
function formatAddress(locationData) {
  return joinWithComma(
    filterInvalid(
      locationDataToArray(locationData)
    )
  );
}
							</code>
						</pre>
					</section>
					<section>
						<pre>
							<code class="hljs" data-trim>
showAddress = curry(function(errorMessage, output, formattedData) {
  if(formattedData) {
    return function() {
      output.textContent = formattedData;
    };
  } else {
    return function() {
      alert(errorMessage);
    };
  }
});
							</code>
						</pre>
					</section>
				</section>

				<section>
					<h2>Coding by composing</h2>
					<h3>Come tornare ai tempi dei Lego!</h3>
				</section>

				<section>
					<section>
						<pre>
							<code class="hljs" data-trim>
Geocoder.prototype.handleGeocodeResult = function (results, status) {
  var locationData = {},
  addressComponents, i, l;

  if (
    results &&
    results.length > 0 &&
    status == google.maps.GeocoderStatus.OK
  ) {
    addressComponents = results[0]['address_components'];

    for(i = 0, l = addressComponents.length; i < l; i++){
      switch(addressComponents[i].types[0]){
        case 'administrative_area_level_2':
          locationData.province = addressComponents[i].short_name;
          break;
        case 'administrative_area_level_3':
          locationData.city = addressComponents[i].long_name;
          break;
        case 'route':
          locationData.route = addressComponents[i].long_name;
          break;
        case 'street_number':
          locationData.streetNumber = addressComponents[i].long_name;
          break;
      }
    }
    this.locationData = locationData;
    this.showAddress();
  } else {
    alert("Geocode was not successful for the following reason: " + status);
  }
};
							</code>
						</pre>
					</section>
					<section>
						<pre>
							<code class="hljs" data-trim>
function transformAddressComponents(addressComponents) {
  return addressComponents.reduce(function(res, component) {
    switch(component.types[0]){
      case 'administrative_area_level_2':
        res.province = component.short_name;
        break;
      case 'administrative_area_level_3':
        res.city = component.long_name;
        break;
      case 'route':
        res.route = component.long_name;
        break;
      case 'street_number':
        res.streetNumber = component.long_name;
        break;
    }
    return locationData;
  }, {});
}

function validGeocodeResponse(results, status) {
  return results && results.length > 0 && status == google.maps.GeocoderStatus.OK;
}
							</code>
						</pre>
					</section>
					<section>
						<pre>
							<code class="hljs" data-trim>
function handleGeocodeResult(results, status) {
  return validGeocodeResponse(results, status)) &&
    results[0]['address_components'] || [];
}

transformAddressComponents(handleGeocodeResult(results, status));
							</code>
						</pre>
					</section>
				</section>
			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>
		<script src="https://maps.googleapis.com/maps/api/js?v=3.exp&amp;client=gme-addictive&amp;channel=geocoder-tool&amp;signed_in=true&amp;libraries=places" async></script>
		<script src="/js/shitty-geocoder.js" async></script>
	</body>
</html>
